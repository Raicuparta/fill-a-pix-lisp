;Grupo 32 75798-Tiago Silva 75863-Marco Domingues 77031-Ruben Dinis 

(load "exemplos.fas")

(defstruct restricao (vars nil) (predicado nil))

(defstruct psr (variaveis nil) (dominio nil) (restricoes nil) (varsList nil) (resList nil) (inferencias nil))

(defun cria-restricao (L P)
  (make-restricao :vars L :predicado P)
)

(defun restricao-variaveis (R)
 (restricao-vars R)
)

(defun restricao-funcao-validacao (R)
  (restricao-predicado R)
)

(defun cria-psr (vars dom res)
	(let ((hashVars (make-hash-table :test 'equal)) 
		 (hashDom (make-hash-table :test 'equal)) 
		 (hashRes (make-hash-table :test 'equal))
		 (count 0)
		 (numRestri 0)
		 (auxRes nil))
				(dolist (el vars)
					(setf (gethash el hashDom) (nth count dom))
					(incf count)
					(dolist (r res)
						(dolist (varR (restricao-vars r))
							(when (equal el varR)
								(setf auxRes (append auxRes (list r)))
								(incf numRestri)
								 )))
					(setf (gethash el hashVars) (cons nil numRestri))
					(setf numRestri 0)
					(setf (gethash el hashRes) auxRes)
					(setf auxRes nil)) 
	(make-psr :variaveis hashVars :dominio hashDom :restricoes hashRes :varsList vars :resList res :inferencias nil))
)

(defun psr-atribuicoes (psr)
	(let (( res nil))
		(loop for key being the hash-keys of (psr-variaveis psr)
        	do (if (not (equal (car (gethash key (psr-variaveis psr))) nil))
				(setf res (append res (list (cons key (car (gethash key (psr-variaveis psr)))))))))
	res)
)

(defun psr-variaveis-todas (psr)
	(psr-varsList psr)
)

(defun psr-variaveis-nao-atribuidas (psr)
	(let ((res nil))
		(dolist (var (psr-varsList psr))
        	(if (equal (car (gethash var (psr-variaveis psr))) nil)
				(setf res (append res (list var)))))
	res)
)

(defun psr-variavel-valor (psr variavel)
	(let ((res (car (gethash variavel (psr-variaveis psr)))))
	res)
)

(defun psr-variavel-dominio (psr variavel)
	(let ((res (gethash variavel (psr-dominio psr))))
	res)
)

(defun psr-variavel-restricoes (psr variavel)
	(let ((res (gethash variavel (psr-restricoes psr))))
	res)
)

(defun psr-adiciona-atribuicao! (psr variavel valor)
	(setf (car (gethash variavel (psr-variaveis psr))) valor)
)

(defun psr-remove-atribuicao! (psr variavel)
	(setf (car (gethash variavel (psr-variaveis psr))) nil)
)

(defun psr-altera-dominio! (psr variavel NewDom)
	(setf (gethash variavel (psr-dominio psr)) NewDom)
) 

(defun psr-completo-p (psr)
	(let ((state t)) 
		(loop for key being the hash-keys of (psr-variaveis psr)
        	do (cond ((equal (car (gethash key (psr-variaveis psr))) nil)
        			(setf state nil)(return))))
		state)
)

(defun psr-consistente-p (psr)
	(let ((num 0) (state t)) 
	    (block loop1
		(dolist (r (psr-resList psr))											
			;lista das variaveis
			(incf num)
			(cond ((funcall (restricao-predicado r) psr) (setf state t))
				(t (setf state nil) (return-from loop1)))))
	(values state num))
)

(defun psr-variavel-consistente-p (psr variavel)
	(let ((num 0) (restList nil) (state t))
	(setf restList (gethash variavel (psr-restricoes psr)))
	(block loop1
		(dolist (res restList)
			(incf num)
			(cond ((funcall (restricao-predicado res) psr) (setf state t))
				(t (setf state nil) (return-from loop1)))))
	(values state num))
) 

(defun psr-atribuicao-consistente-p (psr variavel valor)
	(let ((a nil ) (b 0) (res nil) (oldValue nil))
		(setf oldValue (psr-variavel-valor psr variavel))
		(psr-adiciona-atribuicao! psr variavel valor) 
		(multiple-value-bind (a b) (psr-variavel-consistente-p psr variavel ) (setf res (cons a b)))
		;adicionamos sempre o valor antigo
		(psr-adiciona-atribuicao! psr variavel oldValue)
		(ignore-value a)
		(ignore-value b)
		(values (car res) (cdr res))
	)
)


(defun membro (variavel lst)
	(let ((res nil))
		(block loop1
		(dolist (var lst)
			(cond ((equal variavel var) (setf res t) (return-from loop1)))))
	res)
)

(defun psr-atribuicoes-consistentes-arco-p (psr variavel1 valor1 variavel2 valor2)
	(let ((restList nil) (num 0) (state t) (oldValue1 nil) (oldValue2 nil))
		;valores antigos
		(setf oldValue1 (psr-variavel-valor psr variavel1))
		(setf oldValue2 (psr-variavel-valor psr variavel2))
		(psr-adiciona-atribuicao! psr variavel1 valor1)
		(psr-adiciona-atribuicao! psr variavel2 valor2)
		(setf restList (psr-variavel-restricoes psr variavel1)) 
		(block loop1
			(dolist (r restList)
				(cond ((membro variavel2 (restricao-vars r))
			 			(incf num)
			 	 		(cond ((not (funcall (restricao-predicado r) psr)) (setf state nil) (return-from loop1 )))))))
			 ;adicionamos sempre o valor antigo
		(psr-adiciona-atribuicao! psr variavel1 oldValue1)
		(psr-adiciona-atribuicao! psr variavel2 oldValue2)
		(values state num))
)
;devolve uma restricao
(defun cria-restricoes (array i j valor)
	(let ((vars nil) (pred nil))
		(cond ((and (equal i 0)(equal j 0))
				(setf  vars (list 
								(concatenate 'string "X" (write-to-string i) (write-to-string j))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string j))
								(concatenate 'string "X" (write-to-string i) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (+ j 1)))
							)))
			   ((and (equal i 0)(equal j (- (array-dimension array 1) 1)))
			   	(setf vars (list 	
			   					(concatenate 'string "X" (write-to-string i) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (- j 1)))
								(concatenate 'string "X" (write-to-string i) (write-to-string j))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string j))
						    )))
			   ((equal i 0)
			   	(setf vars (list 
			   					(concatenate 'string "X" (write-to-string i) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (- j 1)))
								(concatenate 'string "X" (write-to-string i) (write-to-string j))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string j))
								(concatenate 'string "X" (write-to-string i) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (+ j 1)))
							)))
			   ((and (equal i (- (array-dimension array 0) 1))(equal j 0))
			   	(setf vars (list
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string j))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string j))
								(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string i) (write-to-string (+ j 1)))
							)))
			   ((equal j 0)
			   	(setf vars (list 
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string j))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string j))
			   					(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string j))
								(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string i) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (+ j 1)))
							)))
			   ((and (equal i (- (array-dimension array 0) 1)) (equal j (- (array-dimension array 1) 1)))
			   	(setf vars (list 
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string (- j 1)))
								(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string j))
								(concatenate 'string "X" (write-to-string i) (write-to-string j))
							)))
			   ((equal i (- (array-dimension array 0) 1))
			   	(setf vars (list 
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string j))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string j))
								(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string i) (write-to-string (+ j 1)))
							)))
			   ((equal j (- (array-dimension array 1) 1))
			   	(setf vars (list 
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string j))
								(concatenate 'string "X" (write-to-string i) (write-to-string j))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string j))
							)))
			   (t 
			   	(setf vars (list 
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (- j 1)))
			   					(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string j))
			   					(concatenate 'string "X" (write-to-string i) (write-to-string j))
			   					(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string j))
								(concatenate 'string "X" (write-to-string (- i 1)) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string i) (write-to-string (+ j 1)))
								(concatenate 'string "X" (write-to-string (+ i 1)) (write-to-string (+ j 1)))
							)))
			)
		(setf pred #'(lambda (psr) (let ((oneNum 0) (state t) (nilNum 0) (zeroNum 0) (atrb 0)) 
										(dolist (var vars)
											(cond ((equal (psr-variavel-valor psr var) nil) (incf nilNum))
												  ((= (psr-variavel-valor psr var) 0) (incf zeroNum))
												  (t (incf oneNum))))
										(setf atrb (+ zeroNum oneNum))
										(cond ((= oneNum valor) (setf state t))
											   ((and (< oneNum valor) (>= (+ oneNum nilNum) valor)) (setf state t))
											   (t (setf state nil)))
										state)))
		(cria-restricao vars pred))

)

(defun fill-a-pix->psr (array)
	;res e uma lista de resricoes 
	(let ((vars nil) (dom nil) (res nil))
        	(dotimes (coluna (array-dimension array 1))
                (dotimes (linha (array-dimension array 0))
                    (setf dom (append dom (list (list 0 1))))
                        (setf vars (append vars (list (concatenate 'string "X" (write-to-string linha) (write-to-string coluna)))))
                            (when (not (equal (aref array linha coluna) nil))
                            	(setf res (append res (list (cria-restricoes array linha coluna (aref array linha coluna))))))))

    (cria-psr vars dom res))
)


(defun psr->fill-a-pix (psr int1 int2)
	(let ((array (make-array (list int1 int2))) (lst (psr-variaveis-todas psr)) (count 0))
		(dotimes (j int2)
			(dotimes (i int1)
				(setf (aref array i j) (car (gethash (nth count lst) (psr-variaveis psr))))
				(incf count)))
	array)
)

(defun backTrackSimples (psr)
	(let ((res nil) (correct nil) (state psr) (count 0) (var nil) (num 0))
		(cond ((not (equal (psr-completo-p psr) t))
			(block loop1
				(setf var (first (psr-variaveis-nao-atribuidas psr)))
					(block loop2
						(dolist (value (psr-variavel-dominio psr var))
							(incf count)
							(multiple-value-bind (a b) (psr-atribuicao-consistente-p psr var value) (setf res (cons a b)))
							(setf num (+ num (cdr res)))
							(cond ((equal (car res) t) (psr-adiciona-atribuicao! psr var value)
									(setf num (+ num (cdr (multiple-value-bind (a b) (backTrackSimples psr) (setf correct (cons a b))))))
									(cond ((equal (car correct) nil)(psr-remove-atribuicao! psr var) )
										))
								(t (cond ((equal count (length (psr-variavel-dominio psr var)))
										(setf state nil) (return-from loop1)))))
							(cond ((equal (psr-completo-p psr) t) (setf state psr) (return-from loop1)))
						))))
		(t (setf state psr)))
		(values state num))
)
						
(defun procura-retrocesso-simples (psr)
	(let ((res nil))
	(multiple-value-bind (a b) (backTrackSimples psr) (setf res (cons a b)))
	(values (car res) (cdr res)))
)

(defun select-var-grau (psr)
	(let ((num 0) (var nil) (numAnt 0))
		(setf var (first (psr-variaveis-nao-atribuidas psr)))
		(dolist (var1 (psr-variaveis-nao-atribuidas psr))
			(dolist (varsRest (psr-variavel-restricoes psr var1))
				(dolist (var2 (restricao-variaveis varsRest))
					(cond ((and (equal (psr-variavel-valor psr var2) nil) (not (equal var1 var2)))
							 (incf num) (return 0)))))
			(cond ((> num numAnt) (setf numAnt num) (setf var var1)))
			(setf num 0))
	var)	
)		

(defun backTrackGrau (psr)
	(let ((res nil) (correct nil) (state psr) (count 0) (var nil) (num 0))
		(cond ((not (equal (psr-completo-p psr) t))
			(block loop1
				(setf var (select-var-grau psr))
					(block loop2
						(dolist (value (psr-variavel-dominio psr var))
							(incf count)
							(multiple-value-bind (a b) (psr-atribuicao-consistente-p psr var value) (setf res (cons a b)))
							(setf num (+ num (cdr res)))
							(cond ((equal (car res) t) (psr-adiciona-atribuicao! psr var value)
									(setf num (+ num (cdr (multiple-value-bind (a b) (backTrackGrau psr) (setf correct (cons a b))))))
									(cond ((equal (car correct) nil)(psr-remove-atribuicao! psr var) )
										))
								(t (cond ((equal count (length (psr-variavel-dominio psr var)))
										(setf state nil) (return-from loop1)))))
							(cond ((equal (psr-completo-p psr) t) (setf state psr) (return-from loop1)))
						))))
		(t (setf state psr)))
		(values state num))
)

(defun procura-retrocesso-grau (psr)
	(let ((res nil))
	(multiple-value-bind (a b) (backTrackGrau psr) (setf res (cons a b)))
	(values (car res) (cdr res)))
)

(defun dominio-apertado (psr)
	(let ((var nil))
		(setf var (first (psr-variaveis-nao-atribuidas psr)))
		(dolist (varPercorridas (psr-variaveis-nao-atribuidas psr))
			(cond ((< (length (psr-variavel-dominio psr varPercorridas)) (length (psr-variavel-dominio psr var)))
				(setf var varPercorridas))))
	;devolve a variavel que tem o dominio mais pequeno
	var)
)

;devolve o dominio da inferencia para a variavel var
(defun psr-variavel-dominio-inferencia (psr var)
	(nth-value 0 (gethash var (psr-inferencias psr)))
)

;recebe uma variavel-nao-atribuida e uma variavel e verifica se a variavel nao atribuida
;esta na lista de restricoes da variavel
(defun var-natribuida-in-restricao (psr var-natribuida var)
	(let ((state nil))
		(dolist (r (psr-variavel-restricoes psr var))
			;lista de variaveis da restricao
			(dolist (varR (restricao-vars r))
				(cond ((equal var-natribuida varR)(return-from var-natribuida-in-restricao t)))))
	state)
)

;ja testei e parece estar tudo bem para varios testes
(defun arcos-vizinhos-nao-atribuidos (psr var)
	(let ((lstArcos nil))
		(dolist (var-natribuida (psr-variaveis-nao-atribuidas psr))
			(cond ((not (equal var var-natribuida))
					(cond ((var-natribuida-in-restricao psr var-natribuida var)
							(setf lstArcos (append lstArcos (list (cons var-natribuida var)))))))))
	lstArcos)
)

(defun actualiza-inferencias (psr var lst)
	(setf (gethash var (psr-inferencias psr)) lst)
)

(defun revise (psr x y inferencias)
	(let ((testesTotais 0) (revised nil) (dominio-x nil) (dominio-y nil) (novo-dominio-x nil) (foundConsistentValue nil) (consistente nil))
		(cond ((equal (gethash x inferencias) nil) 
				(setf dominio-x (psr-variavel-dominio psr x)))
			(t (setf dominio-x (gethash x inferencias))))
		(setf novo-dominio-x dominio-x)

		(cond ((equal (psr-variavel-valor psr y) nil)
				(cond ((equal (gethash y inferencias) nil) 
						(setf dominio-y (psr-variavel-dominio psr y)))
					(t (setf dominio-y (gethash y inferencias)))))
			(t (setf dominio-y (list (psr-variavel-valor psr y)))))
		(dolist (vx dominio-x)
			(setf foundConsistentValue nil)
			(dolist (vy dominio-y)
				(multiple-value-bind (a b) (psr-atribuicoes-consistentes-arco-p psr x vx y vy) (setf consistente (cons a b)))
				(setf testesTotais (+ testesTotais (cdr consistente)))
				(cond ((car consistente)
						(setf foundConsistentValue t)
						(return 0))))
			(cond ((equal foundConsistentValue nil)
					(setf revised t)
					(setf novo-dominio-x (remove vx novo-dominio-x)))))

		(cond ((equal revised t)
				(actualiza-inferencias psr x novo-dominio-x)))

	(values revised testesTotais))
)

(defun forward-checking (psr var)
	(let ((testesTotais 0) (lista-arcos nil) (revise nil))
		(setf (psr-inferencias psr) (make-hash-table :test 'equal))
		(setf lista-arcos (arcos-vizinhos-nao-atribuidos psr var))

		(dolist (arco lista-arcos)
			(multiple-value-bind (a b) (revise psr (car arco) (cdr arco) (psr-inferencias psr)) (setf revise (cons a b)))
			(setf testesTotais (+ testesTotais (cdr revise)))
			(cond ((car revise)
					(cond ((= (length (gethash (car arco) (psr-inferencias psr))) 0)
							(return-from forward-checking (values nil testesTotais)))))))
		(values (psr-inferencias psr) testesTotais))
)

(defun procura-retrocesso-fc-mrv (psr) 
	(let ((testesTotais 0) (var nil) (consistente nil) (inferencias nil) (resultado nil) (oldDom nil))
		(cond ((psr-completo-p psr) (return-from procura-retrocesso-fc-mrv (values psr testesTotais))))
		(setf var (dominio-apertado psr))

		(dolist (valor (psr-variavel-dominio psr var))
			(multiple-value-bind (a b) (psr-atribuicao-consistente-p psr var valor) (setf consistente (cons a b)))
			(setf testesTotais (+ testesTotais (cdr consistente)))
			(cond ((car consistente)
					(psr-adiciona-atribuicao! psr var valor)
					(multiple-value-bind (a b) (forward-checking psr var) (setf inferencias (cons a b)))
					(setf testesTotais (+ testesTotais (cdr inferencias)))
					(cond ((car inferencias)
							(loop for key being the hash-keys of (psr-inferencias psr)
								do (setf oldDom (append oldDom (list (cons key (psr-variavel-dominio psr key)))))
								do (psr-altera-dominio! psr key (gethash key (psr-inferencias psr))))
							(multiple-value-bind (a b) (procura-retrocesso-fc-mrv psr) (setf resultado (cons a b)))
							(setf testesTotais (+ testesTotais (cdr resultado)))
							(cond ((car resultado)
									(return-from procura-retrocesso-fc-mrv (values (car resultado) testesTotais))))
							(dolist (varOldD oldDom)
								(psr-altera-dominio! psr (car varOldD) (cdr varOldD)))))
					(psr-remove-atribuicao! psr var))))
	(values nil testesTotais))
)

(defun remove-arcos (lst arco)
	(let ((res nil))
		(dolist (v1 lst)
			(cond ((not (equal v1 arco)) (setf res (append res (list v1))))))
	res)
)

(defun MAC (psr var)
	(let ((testesTotais 0) (lista-arcos nil) (revise nil) (novos-arcos nil))
		(setf (psr-inferencias psr) (make-hash-table :test 'equal))
		(setf lista-arcos (arcos-vizinhos-nao-atribuidos psr var))

		(dolist (arco lista-arcos)
			(multiple-value-bind (a b) (revise psr (car arco) (cdr arco) (psr-inferencias psr)) (setf revise (cons a b)))
			(setf testesTotais (+ testesTotais (cdr revise)))
			(cond ((car revise)
					(cond ((= (length (gethash (car arco) (psr-inferencias psr))) 0)
							(return-from MAC (values nil testesTotais))))
					(print "lista de arcos")
					(print lista-arcos)
					(setf novos-arcos (arcos-vizinhos-nao-atribuidos psr (car arco)))
					;ver se este arco e' igual ao de cima
					(print "================ NOVOS ARCOS ===========")
					(print novos-arcos)
					(setf novos-arcos (remove-arcos novos-arcos arco))
					(setf lista-arcos (append novos-arcos)))))
	(values (psr-inferencias psr) testesTotais))
)

(defun procura-retrocesso-MAC-mrv (psr) 
	(let ((testesTotais 0) (var nil) (consistente nil) (inferencias nil) (resultado nil) (oldDom nil))
		(cond ((psr-completo-p psr) (return-from procura-retrocesso-MAC-mrv (values psr testesTotais))))
		(setf var (dominio-apertado psr))

		(dolist (valor (psr-variavel-dominio psr var))
			(multiple-value-bind (a b) (psr-atribuicao-consistente-p psr var valor) (setf consistente (cons a b)))
			(setf testesTotais (+ testesTotais (cdr consistente)))
			(cond ((car consistente)
					(psr-adiciona-atribuicao! psr var valor)
					(multiple-value-bind (a b) (MAC psr var) (setf inferencias (cons a b)))
					(setf testesTotais (+ testesTotais (cdr inferencias)))
					(cond ((car inferencias)
							(loop for key being the hash-keys of (psr-inferencias psr)
								do (setf oldDom (append oldDom (list (cons key (psr-variavel-dominio psr key)))))
								do (psr-altera-dominio! psr key (gethash key (psr-inferencias psr))))
							(multiple-value-bind (a b) (procura-retrocesso-MAC-mrv psr) (setf resultado (cons a b)))
							(setf testesTotais (+ testesTotais (cdr resultado)))
							(cond ((car resultado)
									(return-from procura-retrocesso-MAC-mrv (values (car resultado) testesTotais))))
							(dolist (varOldD oldDom)
								(psr-altera-dominio! psr (car varOldD) (cdr varOldD)))))
					(psr-remove-atribuicao! psr var))))
	(values nil testesTotais))
)

(defun resolve-simples(array)
	(let ( (result nil) (solved nil) (res nil) (psr nil))
		(setf psr (fill-a-pix->psr array))
		(multiple-value-bind (a b) (procura-retrocesso-simples psr) (setf res (cons a b)))
		(setf solved (car res))
		(cond ((not (equal solved nil)) (setf result (psr->fill-a-pix solved (array-dimension array 0) (array-dimension array 1))))
				(t (setf result nil)))
		result)
)

(defun resolve-best (array)
	(let ( (result nil) (solved nil) (res nil) (psr nil))
		(setf psr (fill-a-pix->psr array))
		(multiple-value-bind (a b) (procura-retrocesso-fc-mrv psr) (setf res (cons a b)))
		(setf solved (car res))
		(cond ((not (equal solved nil)) (setf result (psr->fill-a-pix solved (array-dimension array 0) (array-dimension array 1))))
				(t (setf result nil)))
		result)
)







